<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Moses</name>
    </assembly>
    <members>
        <member name="T:Moses.ObjectDumper">
            <summary>
            Object Dumper
            </summary>
        </member>
        <member name="M:Moses.ObjectDumper.Write(System.Object)">
            <summary>
            Write
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Moses.ObjectDumper.Write(System.Object,System.Int32)">
            <summary>
            Write
            </summary>
            <param name="element"></param>
            <param name="depth"></param>
        </member>
        <member name="M:Moses.ObjectDumper.Write(System.Object,System.Int32,System.IO.TextWriter)">
            <summary>
            
            </summary>
            <param name="element"></param>
            <param name="depth"></param>
            <param name="log"></param>
        </member>
        <member name="T:Moses.TimeProvider">
            <summary>
            TimeProvider
            </summary>
        </member>
        <member name="P:Moses.TimeProvider.Current">
            <summary>
            Current
            </summary>
        </member>
        <member name="M:Moses.TimeProvider.#ctor">
            <summary>
            TimeProvider
            </summary>
        </member>
        <member name="P:Moses.TimeProvider.Now">
            <summary>
            Now
            </summary>
        </member>
        <member name="P:Moses.TimeProvider.Today">
            <summary>
            Today
            </summary>
        </member>
        <member name="P:Moses.TimeProvider.MaxValue">
            <summary>
            MaxValue
            </summary>
        </member>
        <member name="P:Moses.TimeProvider.MinValue">
            <summary>
            MinValue
            </summary>
        </member>
        <member name="M:Moses.TimeProvider.SetDate(System.DateTime)">
            <summary>
            SetDate
            </summary>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="T:Moses.Data.CompiledExpression">
            <summary>
            Provides the common boxed version of get.
            </summary>
        </member>
        <member name="T:Moses.Data.CompiledExpression`2">
            <summary>
            Represents an expression and its compiled function.
            </summary>
            <typeparam name="TClass">Class the expression relates to.</typeparam>
            <typeparam name="TProperty">Return type of the expression.</typeparam>
        </member>
        <member name="T:Moses.Data.DefaultTranslationOf`1">
            <summary>
            Simple fluent way to access the default translation map.
            </summary>
            <typeparam name="T">Class the expression uses.</typeparam>
        </member>
        <member name="T:Moses.Data.TranslationMap">
            <summary>
            Maintains a list of mappings between properties and their compiled expressions.
            </summary>
        </member>
        <member name="T:Moses.Data.ExpressiveExtensions">
            <summary>
            Extension methods over IQueryable to turn on expression translation via a
            specified or default TranslationMap.
            </summary>
        </member>
        <member name="T:Moses.Data.ExpressiveExtensions.TranslatingVisitor">
            <summary>
            Extends the expression visitor to translate properties to expressions
            according to the provided translation map.
            </summary>
        </member>
        <member name="T:Moses.Data.ComposedManager`3">
            <summary>
            Snippet para um tipo de Manager que carrega dentro de si numa estrutura de propriedade 
            uma entidade Linq
            </summary>
            <typeparam name="T">Classe Portadora da Propriedade</typeparam>
            <typeparam name="K">Classe do DataItem Entity</typeparam>
            <typeparam name="L">DataContext</typeparam>
        </member>
        <member name="M:Moses.Data.ComposedManager`3.AttachBase(`0,System.Boolean)">
            <summary>
            Implementação do Método Attach que usa O AttachBase o parâmetro K
            </summary>
            <param name="item"></param>
            <param name="asModified"></param>
        </member>
        <member name="M:Moses.Data.ComposedManager`3.AttachBase(`1,System.Boolean)">
            <summary>
            Habilita o uso do método Attach
            </summary>
            <example>
            ...
            {
                Context.SystemItems.Attach(dataItem,asModified);
            }
            </example>
            <param name="dataItem"></param>
            <param name="asModified"></param>
        </member>
        <member name="M:Moses.Data.Diagnostics.DebuggerWriter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Moses.Data.Diagnostics.DebuggerWriter"/> class.
            </summary>
        </member>
        <member name="M:Moses.Data.Diagnostics.DebuggerWriter.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Moses.Data.Diagnostics.DebuggerWriter"/> class with the specified level and category.
            </summary>
            <param name="level">A description of the importance of the messages.</param>
            <param name="category">The category of the messages.</param>
        </member>
        <member name="M:Moses.Data.Diagnostics.DebuggerWriter.#ctor(System.Int32,System.String,System.IFormatProvider)">
            <summary>
            Initializes a new instance of the <see cref="T:Moses.Data.Diagnostics.DebuggerWriter"/> class with the specified level, category and format provider.
            </summary>
            <param name="level">A description of the importance of the messages.</param>
            <param name="category">The category of the messages.</param>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> object that controls formatting.</param>
        </member>
        <member name="T:Moses.Data.DataExtensions">
            <summary>
            Helper methods for System.Data and System.Data.Entity types.
            </summary>
        </member>
        <member name="M:Moses.Data.DataExtensions.Field``1(System.Data.IDataRecord,System.String)">
            <summary>
            Returns the value for a field in the given data record.
            </summary>
            <remarks>
            If this method is used within a Materializer expression, it will
            be optimized. If the 'name' argument is a literal, we replace it with
            the column ordinal. In addition, the optimizations described for
            Field(record, ordinal) are applied.
            </remarks>
            <typeparam name="T">Expected type of the field.</typeparam>
            <param name="record">Record from which to retrieve field.</param>
            <param name="name">Name of field.</param>
            <returns>Value of field.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.Field``1(System.Data.IDataRecord,System.Int32)">
            <summary>
            Returns the value for a field in the given data record.
            </summary>
            <remarks>
            If this method is used within a Materializer expression, it will
            be optimized. The record is directly accessed and IsDBNull checks
            are included only if warranted by T.
            </remarks>
            <typeparam name="T">Expected type of the field.</typeparam>
            <param name="record">Record from which to retrieve field.</param>
            <param name="ordinal">Ordinal of field.</param>
            <returns>Value of field.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.Materialize``1(System.Data.Common.DbDataReader)">
            <summary>
            Uses default Materializer behaviors to shape reader results as an enumeration
            of T.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="reader">Data reader producing results.</param>
            <returns>Typed reader results.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.Materialize``1(System.Data.Common.DbDataReader,System.Linq.Expressions.Expression{System.Func{System.Data.IDataRecord,``0}})">
            <summary>
            Uses the given expression to shape reader results as an enumeration of T.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="reader">Data reader producing results.</param>
            <param name="expression">Expression describing how reader results should be shaped.</param>
            <returns>Typed reader results.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.Materialize``1(System.Data.Common.DbCommand)">
            <summary>
            Uses default Materializer behaviors to shape the result of evaluating the given command as 
            an enumeration of T.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="command">Command producing results.</param>
            <returns>Typed reader results.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.Materialize``1(System.Data.Common.DbCommand,System.Data.CommandBehavior)">
            <summary>
            Uses the given expression to shape command results as an enumeration of T.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="command">Data reader producing results.</param>
            <param name="commandBehavior">Command behavior to use when executing the command.</param>
            <returns>Typed reader results.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.Materialize``1(System.Data.Common.DbCommand,System.Linq.Expressions.Expression{System.Func{System.Data.IDataRecord,``0}})">
            <summary>
            Uses the given expression to shape command results as an enumeration of T.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="command">Data reader producing results.</param>
            <param name="expression">Expression describing how reader results should be shaped.</param>
            <returns>Typed reader results.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.Materialize``1(System.Data.Common.DbCommand,System.Data.CommandBehavior,System.Linq.Expressions.Expression{System.Func{System.Data.IDataRecord,``0}})">
            <summary>
            Uses the given expression to shape command results as an enumeration of T.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="command">Data reader producing results.</param>
            <param name="commandBehavior">Command behavior to use when executing the command.</param>
            <param name="expression">Expression describing how reader results should be shaped.</param>
            <returns>Typed reader results.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.CreateStoreCommand(System.Data.Objects.ObjectContext,System.String,System.Object[])">
            <summary>
            Creates a store command based on the connection used by given object context.
            </summary>
            <param name="context">Object context.</param>
            <param name="commandText">Command text.</param>
            <param name="parameters">Parameters to pass to the store command.</param>
            <returns>Store command.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.CreateStoreCommand(System.Data.Objects.ObjectContext,System.String,System.Data.CommandType,System.Object[])">
            <summary>
            Creates a store command based on the connection used by given object context.
            </summary>
            <param name="context">Object context.</param>
            <param name="commandText">Command text.</param>
            <param name="commandType">Command type.</param>
            <param name="parameters">Parameters to pass to the store command.</param>
            <returns>Store command.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.Bind``2(System.Collections.Generic.IEnumerable{``0},Moses.Data.EntitySet{``1})">
            <summary>
            Associates results in the given source with an entity set. This supports tracking
            results in the state manager. If an existing element with the same key exists, it
            is returned instead.
            </summary>
            <typeparam name="TEntity">Entity type.</typeparam>
            <typeparam name="TBase">Base type for entity set.</typeparam>
            <param name="source">Entities to bind.</param>
            <param name="entitySet">Entity set to which elements should be bound.</param>
            <returns>Bound entities.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.Bind``1(System.Collections.Generic.IEnumerable{``0},System.Data.Objects.ObjectContext)">
            <summary>
            Associates results in the given source with the default entity set for the given entity type. 
            This supports tracking results in the state manager. If an existing element with the same key 
            exists, it is returned instead.
            </summary>
            <typeparam name="TEntity">Entity type.</typeparam>
            <param name="source">Entities to bind.</param>
            <param name="context">Object context to which entities are bound.</param>
            <returns>Bound entities.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.CreateConnectionScope(System.Data.Common.DbConnection)">
            <summary>
            Returns a handle on an IDisposable that can be used to safely control the lifetime
            of an open connection. If the connection is closed, it will be opened immediately
            and closed when the result of this method (the scope) is disposed. If the connection is already
            open, it remains open.
            <code>
            // Example with CreateConnectionScope
            using (command.Connection.CreateConnectionScope())
            {
                command.ExecuteNonQuery();
            }
            
            // Example without
            bool connectionOpened = command.Connection.State == ConnectionState.Closed;
            if (connectionOpened)
            {
                command.Connection.Open();
            }
            try
            {
                command.ExecuteNonQuery();
            }
            finally
            {
                if (connectionOpened &amp;&amp; command.Connection.State == ConnectionState.Open)
                {
                    command.Connection.Close();
                }
            }
            </code>
            </summary>
            <param name="connection">Connection to open.</param>
            <returns>Scope closing the connection on dispose.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.ExpandInvocations(System.Linq.Expressions.Expression)">
            <summary>
            Expands all InvocationExpression instances within the given expression.
            </summary>
            <param name="expression">Expression to expand.</param>
            <returns>Expanded expression.</returns>
        </member>
        <member name="M:Moses.Data.DataExtensions.ExpandInvocations``1(System.Linq.IQueryable{``0})">
            <summary>
            Expands all InvocationExpression instances within the given query.
            </summary>
            <param name="query">Query to expand.</param>
            <returns>Expanded query.</returns>
        </member>
        <member name="T:Moses.Data.DataExtensions.InvocationExpander">
            <summary>
            Expands invocation expressions by replacing parameters with values.
            </summary>
        </member>
        <member name="T:Moses.Data.DataExtensions.FieldMethodOptimizer">
            <summary>
            Optimizer implementation that rewrites calls to the DataExtensions.Field methods.
            </summary>
        </member>
        <member name="T:Moses.Data.DataExtensions.OpenConnectionLifetime">
            <summary>
            Class supporting the DataExtensions.OpenConnection method.
            </summary>
        </member>
        <member name="T:Moses.Data.EntityReferenceExtensions">
            <summary>
            Extensions supporting easy retrieval and setting of reference key values. Currently, the EntityReference
            class requires metadata for a key but does not directly expose that metadata. This class exposes the 
            keys as pure values.
            </summary>
            <example>
            <code>
            // existing pattern
            product.CategoryReference.EntityKey = new EntityKey("EntityContainer.Categories", new EntityKeyMember("CategoryID", 1), new EntityKeyMember("DivisionID", 1))); 
            
            // new pattern
            product.CategoryReference.SetKey(1, 1);
            </code>
            </example>
        </member>
        <member name="M:Moses.Data.EntityReferenceExtensions.GetKey``1(System.Data.Objects.DataClasses.EntityReference{``0})">
            <summary>
            Gets key value for a non-compound reference key (e.g. one foreign key component).
            </summary>
            <typeparam name="T">EntityReference element type</typeparam>
            <param name="entityReference">Entity reference.</param>
            <returns>Key value from entity reference.</returns>
        </member>
        <member name="M:Moses.Data.EntityReferenceExtensions.GetKey``1(System.Data.Objects.DataClasses.EntityReference{``0},System.Int32)">
            <summary>
            Gets a component of a key value for a (potentially compound) reference key.
            </summary>
            <typeparam name="T">EntityReference element type</typeparam>
            <param name="entityReference">Entity reference.</param>
            <param name="keyOrdinal">Index of the key component (with respect to the element type's
            EntityType.KeyMembers).</param>
            <returns>Key component value from entity reference.</returns>
        </member>
        <member name="M:Moses.Data.EntityReferenceExtensions.SetKey``1(System.Data.Objects.DataClasses.EntityReference{``0},System.Object[])">
            <summary>
            Sets reference key values.
            </summary>
            <typeparam name="T">EntityReference element type</typeparam>
            <param name="entityReference">Entity reference.</param>
            <param name="keyValues">Components of the key (aligned with the element type EntityType.KeyMembers)</param>
        </member>
        <member name="M:Moses.Data.EntityReferenceExtensions.GetTargetEntitySet(System.Data.Objects.DataClasses.RelatedEnd)">
            <summary>
            Uses internal API to access metadata for related end target.
            </summary>
            <param name="relatedEnd">Related end.</param>
            <returns>Entity set targeted by the related end.</returns>
        </member>
        <member name="M:Moses.Data.EntitySet`1.#ctor(System.Data.Objects.ObjectContext)">
            <summary>
            Constructs an entity set query.
            </summary>
            <param name="context">Context to which entity set is bound.</param>
        </member>
        <member name="M:Moses.Data.EntitySet`1.#ctor(System.Data.Objects.ObjectContext,System.String)">
            <summary>
            Construct an entity set query.
            </summary>
            <param name="context">Context to which entity set is bound.</param>
            <param name="entitySetName">Name of the entity set. Must be consistent with the
            entity set element type.</param>
        </member>
        <member name="M:Moses.Data.EntitySet`1.#ctor(System.Data.Objects.ObjectContext,System.String,System.Data.Objects.MergeOption)">
            <summary>
            Construct an entity set query.
            </summary>
            <param name="context">Context to which entity set is bound.</param>
            <param name="entitySetName">Name of the entity set. Must be consistent with the
            entity set element type.</param>
            <param name="mergeOption">Merge option to use for the query.</param>
        </member>
        <member name="M:Moses.Data.EntitySet`1.#ctor(System.Data.Objects.ObjectContext,System.String,System.String)">
            <summary>
            Construct an entity set query.
            </summary>
            <param name="context">Context to which entity set is bound.</param>
            <param name="containerName">Name of the entity set's container.</param>
            <param name="entitySetName">Name of the entity set. Must be consistent with the
            entity set element type.</param>
        </member>
        <member name="M:Moses.Data.EntitySet`1.#ctor(System.Data.Objects.ObjectContext,System.String,System.String,System.Data.Objects.MergeOption)">
            <summary>
            Construct an entity set query.
            </summary>
            <param name="context">Context to which entity set is bound.</param>
            <param name="containerName">Name of the entity set's container.</param>
            <param name="entitySetName">Name of the entity set. Must be consistent with the
            entity set element type.</param>
            <param name="mergeOption">Merge option to use for the query.</param>
        </member>
        <member name="P:Moses.Data.EntitySet`1.Metadata">
            <summary>
            Gets metadata for the EntitySet.
            </summary>
        </member>
        <member name="P:Moses.Data.EntitySet`1.QualifiedEntitySetName">
            <summary>
            Gets qualified entity set name. Used to associate entities with the set.
            </summary>
        </member>
        <member name="M:Moses.Data.EntitySet`1.InsertOnSaveChanges(`0)">
            <summary>
            Tracks a new entity for insertion when ObjectContext.SaveChanges is called.
            </summary>
            <param name="entity">Entity to insert.</param>
        </member>
        <member name="M:Moses.Data.EntitySet`1.DeleteOnSaveChanges(`0)">
            <summary>
            Removes an entity from the EntitySet. The entity will be deleted
            when ObjectContext.SaveChanges is called.
            </summary>
            <param name="entity">Entity to delete.</param>
        </member>
        <member name="M:Moses.Data.EntitySet`1.Attach(`0)">
            <summary>
            Attaches an existing entity to the current entity set.
            </summary>
            <param name="entity">Entity to attach.</param>
        </member>
        <member name="M:Moses.Data.EntitySet`1.FindOrAttach``1(``0)">
            <summary>
            Attaches the given entity or returns existing entity with the same key.
            </summary>
            <typeparam name="TEntity">Entity type.</typeparam>
            <param name="entity">Entity to attach.</param>
            <returns>Input entity or existing entity with the same key.</returns>
        </member>
        <member name="M:Moses.Data.EntitySet`1.GetTrackedEntities">
            <summary>
            Gets all members of the EntitySet that are currently in memory.
            </summary>
            <returns>All tracked members of the EntitySet</returns>
        </member>
        <member name="M:Moses.Data.EntitySet`1.GetTrackedEntities(System.Data.EntityState)">
            <summary>
            Gets all members of the EntitySet that are currently in memory
            with the given state(s).
            </summary>
            <param name="state">Entity state flags.</param>
            <returns>Tracked members of the EntitySet in the given state.</returns>
        </member>
        <member name="T:Moses.Data.Materializer`1">
            <summary>
            Supports shaping DbCommand and DbDataReader as CLR instances.
            </summary>
            <remarks>
            This type is thread-safe. For performance reasons, static instances of this type
            should be shared wherever possible. Note that a single instance of the Materializer
            cannot be used with two command or readers returning different fields or the same
            fields in a different order. To develop custom optimization behaviors, implement
            methods with the IMaterializerOptimizedMethodAttribute.
            </remarks>
            <typeparam name="T">CLR type to materialize.</typeparam>
        </member>
        <member name="M:Moses.Data.Materializer`1.#ctor">
            <summary>
            Default constructor. Instances of T are materialized by assigning field values to
            writable properties on T having the same name. By default, allows fields
            that do not have corresponding properties and properties that do not have corresponding
            fields.
            </summary>
        </member>
        <member name="M:Moses.Data.Materializer`1.#ctor(System.Data.Metadata.Edm.StructuralType)">
            <summary>
            Creates a materializer for the given EDM type. Assumes that a column exists in the result
            set for every property of the EDM type.
            </summary>
            <remarks>
            Beyond requiring that all properties of the type are available, no type validation
            is performed.
            </remarks>
            <param name="structuralType">EDM type for which to create a Materializer.</param>
        </member>
        <member name="M:Moses.Data.Materializer`1.#ctor(System.Linq.Expressions.Expression{System.Func{System.Data.IDataRecord,`0}})">
            <summary>
            Instances of T are materialized using the given shaper. For every row in the result,
            the shaper is evaluated.
            </summary>
            <param name="shaper">Describes how reader rows are transformed into typed results.</param>
        </member>
        <member name="M:Moses.Data.Materializer`1.Materialize(System.Data.Common.DbCommand)">
            <summary>
            Materializes the results of the given command.
            </summary>
            <param name="command">Command to execute.</param>
            <returns>Shaped results.</returns>
        </member>
        <member name="M:Moses.Data.Materializer`1.Materialize(System.Data.Common.DbCommand,System.Data.CommandBehavior)">
            <summary>
            Materializes the results of the given command.
            </summary>
            <param name="command">Command to execute.</param>
            <param name="commandBehavior">Command behavior to use when executing the command.</param>
            <returns>Shaped results.</returns>
        </member>
        <member name="M:Moses.Data.Materializer`1.Materialize(System.Data.Common.DbDataReader)">
            <summary>
            Materializes rows in the given reader.
            </summary>
            <param name="reader">Results to materialize.</param>
            <returns>Shaped results.</returns>
        </member>
        <member name="T:Moses.Data.Materializer`1.OptimizingExpressionVisitor">
            <summary>
            LINQ expression visitor that optimizes method call expressions referencing methods with
            the IMaterializerMethodAttribute.
            </summary>
        </member>
        <member name="T:Moses.Data.MaterializerOptimizedMethodAttribute">
            <summary>
            Attach this attribute to a method that can be locally rewritten to optimize Materializer
            performance.
            </summary>
        </member>
        <member name="M:Moses.Data.MaterializerOptimizedMethodAttribute.#ctor(System.Type)">
            <summary>
            Construct attribute.
            </summary>
            <param name="optimizerType">A type implementing the IMaterializerMethodOptimizer interface
            that can be used to optimize MethodCallExpressions referencing the attributed method. The
            type must have a public default constructor.</param>
        </member>
        <member name="P:Moses.Data.MaterializerOptimizedMethodAttribute.OptimizerType">
            <summary>
            Gets type of optimizer.
            </summary>
        </member>
        <member name="P:Moses.Data.MaterializerOptimizedMethodAttribute.Optimizer">
            <summary>
            Instance of the optimizer class.
            </summary>
        </member>
        <member name="T:Moses.Data.IMaterializerMethodOptimizer">
            <summary>
            Interface method optimizers must implement to be used by the Materializer component.
            </summary>
        </member>
        <member name="M:Moses.Data.IMaterializerMethodOptimizer.OptimizeMethodCall(System.Collections.ObjectModel.ReadOnlyCollection{System.String},System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Optimize a method call.
            </summary>
            <remarks>
            Implementations should return the input expression if they are unable to optimize
            rather than throwing or returning null.
            </remarks>
            <param name="fieldNames">Names and order of fields available in the given record.</param>
            <param name="recordParameter">Record parameter (of type IDataRecord).</param>
            <param name="methodCall">Expression representing the method call.</param>
            <returns>Optimized method call.</returns>
        </member>
        <member name="T:Moses.Data.EFExtensions.Messages">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.AmbiguousEntitySet">
            <summary>
              Looks up a localized string similar to More than one entity set supports the given element type &apos;{0}&apos;. You must specify an entity set..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.AttachedEntityHasWrongType">
            <summary>
              Looks up a localized string similar to The given type argument to does not match the type of an entity found in the state manager..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.CannotDetermineMetadataForRelatedEnd">
            <summary>
              Looks up a localized string similar to Unable to retrieve metadata for related end..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.DeletingFromWrongSet">
            <summary>
              Looks up a localized string similar to Attempting to delete an entity belonging to a different set..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.EmptyArgument">
            <summary>
              Looks up a localized string similar to Argument is empty..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.IncompatibleReader">
            <summary>
              Looks up a localized string similar to The given reader is incompatible with the current materializer. Create a different materializer for this reader..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.InvalidOptimizerType">
            <summary>
              Looks up a localized string similar to The given type must implement &apos;{0}&apos; and have a default constructor..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.InvalidSourceEntity">
            <summary>
              Looks up a localized string similar to Source entity did not contribute the given reference..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.NoEntitySet">
            <summary>
              Looks up a localized string similar to No entity set was found supporting the given element type &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.OperationRequiresObjectQuery">
            <summary>
              Looks up a localized string similar to The argument must be an instance of System.Data.Objects.ObjectQuery&apos;1..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.OptimizedExpressionUnavailable">
            <summary>
              Looks up a localized string similar to An optimized expression cannot be produced before results have been materialized..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.SimpleKeyOnly">
            <summary>
              Looks up a localized string similar to This method is only supported for non-compound reference keys.
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.UnableToCreateDefaultMaterializeDelegate">
            <summary>
              Looks up a localized string similar to Unable to build a default materialization delegate for this type. Initialize a materializer with a specific delegate definition..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.UnableToFindMetadataForType">
            <summary>
              Looks up a localized string similar to Unable to find EDM metadata for the given CLR type &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.UnableToGetBindingList">
            <summary>
              Looks up a localized string similar to The given query does not support binding lists..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.UnexpectedKeyCount">
            <summary>
              Looks up a localized string similar to Unexpected number of key values given..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.UnknownEntityContainer">
            <summary>
              Looks up a localized string similar to Unable to find specified entity container &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.UnknownEntitySet">
            <summary>
              Looks up a localized string similar to Unable to find specified entity set &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Moses.Data.EFExtensions.Messages.UntrackedEntity">
            <summary>
              Looks up a localized string similar to Entity is not tracked by the current object context..
            </summary>
        </member>
        <member name="T:Moses.Data.ObjectQueryExtensions">
            <summary>
            When using LINQ to Entities, queries are instances of ObjectQuery but are statically
            typed as IQueryable. This makes it difficult to access members of ObjectQuery, particularly
            when the element type is anonymous. These extensions make it easier to access ObjectQuery
            members.
            </summary>
            <example>
            <code>
            var q = from p in context.Products
                    where p.ProductName.StartsWith("Foo")
                    select p;
            
            // before
            string commandText = ((ObjectQuery&lt;Product&gt;)q).ToTraceString();
            
            // after
            string commandText = q.ToTraceString();
            </code>
            </example>
        </member>
        <member name="M:Moses.Data.ObjectQueryExtensions.AsObjectQuery``1(System.Linq.IQueryable{``0})">
            <summary>
            Returns the given IQuerable instance as an ObjectQuery instance.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="source">IQueryable instance.</param>
            <returns>source as an ObjectQuery</returns>
        </member>
        <member name="M:Moses.Data.ObjectQueryExtensions.ToTraceString``1(System.Linq.IQueryable{``0})">
            <summary>
            Retrieves Entity Framework trace information for the given query.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="source">IQueryable instance. Must be an ObjectQuery instance at runtime.</param>
            <returns>Trace string for the query.</returns>
        </member>
        <member name="M:Moses.Data.ObjectQueryExtensions.Include``1(System.Linq.IQueryable{``0},System.String)">
            <summary>
            Includes navigation path in query result.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="source">IQueryable instance. Must be an ObjectQuery instance at runtime.</param>
            <param name="path">Navigation path.</param>
            <returns>Query with spanned navigations.</returns>
        </member>
        <member name="M:Moses.Data.ObjectQueryExtensions.SetMergeOption``1(System.Linq.IQueryable{``0},System.Data.Objects.MergeOption)">
            <summary>
            Sets merge option for a query.
            </summary>
            <typeparam name="T">Element type.</typeparam>
            <param name="source">IQueryable instance. Must be an ObjectQuery instance at runtime.</param>
            <param name="mergeOption">Merge option to use when evaluating the query.</param>
            <returns>Query with merge option set.</returns>
        </member>
        <member name="M:Moses.Data.ObjectQueryExtensions.ToBindingList``1(System.Linq.IQueryable{``0})">
            <summary>
            Returns binding list for the given query instance.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:Moses.Data.Utility">
            <summary>
            General purpose helper methods.
            </summary>
        </member>
        <member name="M:Moses.Data.Utility.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Zips together two sequences (aligns values in the two sequences and returns them pair-wise).
            </summary>
            <typeparam name="TLeft">Element type for the left sequence.</typeparam>
            <typeparam name="TRight">Element type for the right sequence.</typeparam>
            <typeparam name="TResult">Element type for the result sequence.</typeparam>
            <param name="left">Left sequence.</param>
            <param name="right">Right sequence.</param>
            <param name="resultSelector">Result selector that takes a (left, right) pair.</param>
            <returns>Zipped results.</returns>
        </member>
        <member name="M:Moses.Data.Utility.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Foreach element in the input, runs the specified action. Yields input elements.
            </summary>
            <typeparam name="TResult">Element type.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="action">Action to perform on each element of the source.</param>
            <returns>Source elements.</returns>
        </member>
        <member name="M:Moses.Data.Utility.IsGenericAssignableFrom(System.Type,System.Type,System.Type[]@)">
            <summary>
            Determines whether a generic type definition is assignable from a type given some
            generic type arguments. For instance, <code>typeof(IEnumerable&lt;&gt;).IsGenericAssignableFrom(typeof(List&lt;int&gt;), out genericArguments)</code>
            returns true with generic arguments { typeof(int) }.
            </summary>
            <param name="toType">Target generic type definition (to which the value would be assigned).</param>
            <param name="fromType">Source type (instance of which is being assigned)</param>
            <param name="genericArguments">Returns generic type arguments required for the assignment to succeed
            or null if no such assignment exists.</param>
            <returns>true if the type can be assigned; otherwise false</returns>
        </member>
        <member name="M:Moses.Data.DataFactoryHelper.ExecuteSP(System.Data.Linq.DataContext,System.String,System.Data.SqlClient.SqlParameter[])">
            <summary>
            Executa uma SP com parâmetros
            </summary>
            <param name="conn"></param>
            <param name="spName"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Moses.Data.DataFactoryHelper.ExecuteScalarSP``1(System.Data.Linq.DataContext,System.String,System.Data.SqlClient.SqlParameter[])">
            <summary>
            Roda uma Stored Procedure
            </summary>
            <typeparam name="T"></typeparam>
            <param name="conn">Conexão para executar a sp, não necessita estar aberta</param>
            <param name="spName"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Moses.Data.DataFactoryHelper.ExecuteScalarFunction``1(System.Data.Linq.DataContext,System.String,System.Data.SqlClient.SqlParameter[])">
            <summary>
            Roda uma Function Sql
            </summary>
            <typeparam name="T"></typeparam>
            <param name="conn">Conexão para executar a sp, não necessita estar aberta</param>
            <param name="spName"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:Moses.Data.Manager`2">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="K"></typeparam>
        </member>
        <member name="M:Moses.Data.Manager`2.#ctor">
            <summary>
            Construtor padrão da classe. Cria um novo DataContext e retorna a referência do Manager
            </summary>
        </member>
        <member name="M:Moses.Data.Manager`2.#ctor(`1)">
            <summary>
            Construtor da classe que recebe DataContext e retorna a referência do Manager com a referida referência
            </summary>
        </member>
        <member name="T:Moses.Data.ManagerBase`1">
            <summary>
            Classe Básica de representação da estrutura de acesso a dados no Moses 3.0
            </summary>
        </member>
        <member name="M:Moses.Data.ManagerBase`1.#ctor">
            <summary>
            Construtor padrão da classe. Cria um novo DataContext e retorna a referência do Manager
            </summary>
        </member>
        <member name="M:Moses.Data.ManagerBase`1.#ctor(`0)">
            <summary>
            Construtor da classe que recebe DataContext e retorna a referência do Manager com a referida referência
            </summary>
        </member>
        <member name="M:Moses.Data.ManagerBase`1.SubmitChanges">
            <summary>
            Executa o SubmitChanges do DataContext controlado pelo manager
            </summary>
        </member>
        <member name="P:Moses.Data.ManagerBase`1.Context">
            <summary>
            Referência para o DataContext
            </summary>
        </member>
        <member name="M:Moses.Data.ManagerBase`1.GetNewDataContext">
            <summary>
            Deve retornar o DataContext para ser uDsado internamente na Criação do DataContext dentro do construtor
            da classe
            </summary>
            <returns></returns>
        </member>
        <member name="T:Moses.Data.Parser.FieldType">
            <summary>
              Indicates whether text fields are delimited or fixed width.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.FieldType.Delimited">
            <summary>
              Indicates that the fields are delimited.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.FieldType.FixedWidth">
            <summary>
              Indicates that the fields are fixed width.
            </summary>
        </member>
        <member name="T:Moses.Data.Parser.Flat.IFileReaderField">
            <summary>
            Guarda a estrutura dos campos
            </summary>
        </member>
        <member name="T:Moses.Data.Parser.GenericParser">
            <summary>
            The <see cref="T:Moses.Data.Parser.GenericParser"/> class is designed to be a flexible and efficient manner
            of parsing various flat files formats.
            </summary>
            <threadsafety static="false" instance="false"/>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultMaxBufferSize">
            <summary>
              Defines the default max buffer size (4096).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultMaxRows">
            <summary>
              Defines the max rows value (0 = no limit).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultSkipStartingDataRows">
            <summary>
              Defines the number of skip starting data rows (0).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultExpectedColumnCount">
            <summary>
              Defines the number of expected columns (0 = no limit).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultFirstRowHasHeader">
            <summary>
              Defines the default first row has a header (false).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultTrimResults">
            <summary>
              Defines the default value for trim results (false).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaulStripControlCharacters">
            <summary>
              Defines the default value for stripping control characters (false).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaulSkipEmptyRows">
            <summary>
              Defines the default value for skipping empty rows (true).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultTextFieldType">
            <summary>
              Defines the default value for text field type (Delimited).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultFirstRowSetsExpectedColumnCount">
            <summary>
              Defines the default for first row sets the expected column count (false).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultColumnDelimiter">
            <summary>
              Defines the default column delimiter (',').
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultTextQualifier">
            <summary>
              Defines the default text qualifier ('\"').
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.DefaultCommentCharacter">
            <summary>
              Defines the default comment row character ('#').
            </summary>
        </member>
        <member name="T:Moses.Data.Parser.GenericParser.RowType">
            <summary>
              Indicates the current type of row being processed.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.RowType.Unknown">
            <summary>
              The row type is unknown and needs to be determined.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.RowType.CommentRow">
            <summary>
              The row type is a comment row and can be ignored.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.RowType.HeaderRow">
            <summary>
              The row type is a header row to name the columns.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.RowType.SkippedRow">
            <summary>
              The row type is a skipped row that is not intended to be extracted.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.RowType.DataRow">
            <summary>
              The row type is data row that is intended to be extracted.
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.CloneArray``1(``0[])">
            <summary>
              Clones the provided array in a type-friendly way.
            </summary>
            <typeparam name="T">The type of the array to clone.</typeparam>
            <param name="array">The array to clone.</param>
            <returns>The cloned version of the array.</returns>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.#ctor">
            <summary>
              Constructs an instance of a <see cref="T:Moses.Data.Parser.GenericParser"/> with the default settings.
            </summary>
            <remarks>
              When using this constructor, the datasource must be set prior to using the parser
              (using <see cref="M:Moses.Data.Parser.GenericParser.SetDataSource(System.String)"/>), otherwise an exception will be thrown.
            </remarks>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.#ctor(System.String)">
            <summary>
              Constructs an instance of a <see cref="T:Moses.Data.Parser.GenericParser"/> and sets the initial datasource
              as the file referenced by the string passed in.
            </summary>
            <param name="strFileName">The file name to set as the initial datasource.</param>
            <exception cref="T:System.ArgumentNullException">Supplying <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">Supplying a filename to a file that does not exist.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.#ctor(System.String,System.Text.Encoding)">
            <summary>
              Constructs an instance of a <see cref="T:Moses.Data.Parser.GenericParser"/> and sets the initial datasource
              as the file referenced by the string passed in with the provided encoding.
            </summary>
            <param name="strFileName">The file name to set as the initial datasource.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> of the file being referenced.</param>
            <exception cref="T:System.ArgumentNullException">Supplying <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">Supplying a filename to a file that does not exist.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.#ctor(System.IO.TextReader)">
            <summary>
              Constructs an instance of a <see cref="T:Moses.Data.Parser.GenericParser"/> and sets the initial datasource
              as the <see cref="T:System.IO.TextReader"/> passed in.
            </summary>
            <param name="txtReader">The <see cref="T:System.IO.TextReader"/> containing the data to be parsed.</param>
            <exception cref="T:System.ArgumentNullException">Supplying <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.IsDisposed">
            <summary>
               Gets whether or not the instance has been disposed of.
            </summary>
            <value>
              <para>
                <see langword="true"/> - Indicates the instance has be disposed of.
              </para>
              <para>
                <see langword="false"/> - Indicates the instance has not be disposed of.
              </para>
            </value>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.ColumnWidths">
            <summary>
              Gets or sets an integer array indicating the number of characters needed for each column.
            </summary>
            <value>An int[] containing the number of spaces for each column.</value>
            <remarks>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
              <para>
                By setting this property, the <see cref="P:Moses.Data.Parser.GenericParser.TextFieldType"/> and <see cref="P:Moses.Data.Parser.GenericParser.ExpectedColumnCount"/> are automatically updated.
              </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Passing in an empty array or an
            array of values that have a number less than one.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.MaxBufferSize">
            <summary>
              Gets or sets the maximum size of the internal buffer used to cache the data.
            </summary>
            <value>The maximum size of the internal buffer to cache data from the datasource.</value>
            <remarks>
              <para>
                Maintaining the smallest number possible here improves memory usage, but
                trades it off for higher CPU usage. The <see cref="P:Moses.Data.Parser.GenericParser.MaxBufferSize"/> must
                be at least the size of one column of data, plus the Max(column delimiter
                width, row delimiter width).
              </para>
              <para>
                Default: 4096
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Setting the value to something less than one.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.MaxRows">
            <summary>
              Gets or sets the maximum number of rows to parse.
            </summary>
            <value>The maximum number of rows to parse.</value>
            <remarks>
              <para>
                Setting the value to zero will cause all of the rows to be returned.
              </para>
             <para>
               Default: 0
             </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.SkipStartingDataRows">
            <summary>
              Gets or sets the number of rows of data to ignore at the start of the file.
            </summary>
            <value>The number of data rows to initially skip in the datasource.</value>
            <remarks>
              <para>
                The header row (if present) and comment rows will not be taken into account
                when determining the number of rows to skip. Setting the value to zero will
                cause no rows to be ignored.
              </para>
              <para>
                Default: 0
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.DataRowNumber">
            <summary>
              Gets or sets the number of rows of data that have currently been parsed.
            </summary>
            <value>The number of rows of data that have been parsed.</value>
            <remarks>The DataRowNumber property is read-only.</remarks>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.FileRowNumber">
            <summary>
              Gets or sets how many rows in the file have been parsed.
            </summary>
            <value>The number of rows in the file that have been parsed.</value>
            <remarks>The <see cref="P:Moses.Data.Parser.GenericParser.FileRowNumber"/> property is read-only and includes all
            rows possible (header, comment, and data).</remarks>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.ExpectedColumnCount">
            <summary>
              Gets or sets the expected number of columns to find in the data.  If
              the number of columns differs, an exception will be thrown.
            </summary>
            <value>The number of columns expected per row of data.</value>
            <remarks>
              <para>
                Setting the value to zero will cause the <see cref="T:Moses.Data.Parser.GenericParser"/> to ignore
                the column count in case the number changes per row.
              </para>
              <para>
                Default: 0
              </para>
              <para>
                By setting this property, the <see cref="P:Moses.Data.Parser.GenericParser.TextFieldType"/> and <see cref="P:Moses.Data.Parser.GenericParser.ColumnWidths"/>
                are automatically updated.
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.FirstRowHasHeader">
            <summary>
              Gets or sets whether or not the first row of data in the file contains
              the header information.
            </summary>
            <value>
              <para>
                <see langword="true"/> - Header found on first 'data row'.
              </para>
              <para>
                <see langword="false"/> - Header row does not exist.
              </para>
            </value>
            <remarks>
              <para>
                Default: <see langword="false"/>
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.TrimResults">
            <summary>
              Gets or sets whether or not to trim the values for each column.
            </summary>
            <value>
              <para>
                <see langword="true"/> - Indicates to trim the resulting strings.
              </para>
              <para>
                <see langword="false"/> - Indicates to not trim the resulting strings.
              </para>
            </value>
            <remarks>
              <para>
                Trimming only occurs on the strings if they are not text qualified.
                So by placing values in quotes, it preserves all whitespace within
                quotes.
              </para>
              <para>
                Default: <see langword="false"/>
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.StripControlChars">
            <summary>
              Gets or sets whether or not to strip control characters out of the input.
            </summary>
            <value>
              <para>
                <see langword="true"/> - Indicates to remove control characters from the input.
              </para>
              <para>
                <see langword="false"/> - Indicates to leave control characters in the input.
              </para>
            </value>
            <remarks>
              <para>
                Setting this to <see langword="true"/> can cause a performance boost.
              </para>
              <para>
                Default: <see langword="false"/>
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.SkipEmptyRows">
            <summary>
              Gets or sets whether or not to skip empty rows in the input.
            </summary>
            <value>
              <para>
                <see langword="true"/> - Indicates to skip empty rows in the input.
              </para>
              <para>
                <see langword="false"/> - Indicates to include empty rows in the input.
              </para>
            </value>
            <remarks>
              <para>
                Default: <see langword="true"/>
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.IsCurrentRowEmpty">
            <summary>
              Gets whether or not the current row is an empty row.
            </summary>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.TextFieldType">
            <summary>
              Gets or sets the <see cref="T:Moses.Data.Parser.FieldType"/> of the data encoded in the rows.
            </summary>
            <remarks>
              <para>
                By setting <see cref="P:Moses.Data.Parser.GenericParser.ColumnWidths"/>, this property is automatically set.
              </para>
              <para>
                Default: <see cref="F:Moses.Data.Parser.FieldType.Delimited"/>
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.FirstRowSetsExpectedColumnCount">
            <summary>
              Gets or sets the number of columns in the header/first data row determines
              the expected number of columns in the data.
            </summary>
            <value>
              <para>
                <see langword="true"/> - Indicates the data's column count should match the header/first data row's column count.
              </para>
              <para>
                <see langword="false"/> - Indicates the data's column count does not necessarily match the header/first data row's column count.
              </para>
            </value>
            <remarks>
              <para>
                If set to <see langword="true"/>, <see cref="T:Moses.Data.Parser.FieldType"/> will automatically be set to <see langword="false"/>.
              </para>
              <para>
                Default: <see langword="false"/>
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.State">
            <summary>
              Gets the <see cref="T:Moses.Data.Parser.ParserState"/> value indicating the current
              internal state of the parser.
            </summary>
            <value>The <see cref="P:Moses.Data.Parser.GenericParser.State"/> property is read-only and is used to return
            information about the internal state of the parser.</value>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.ColumnDelimiter">
            <summary>
              Gets or sets the character used to match the end of a column of data.
            </summary>
            <value>Contains the character used to delimit a column.</value>
            <remarks>
              <para>
                By setting this property, the <see cref="P:Moses.Data.Parser.GenericParser.TextFieldType"/> is automatically
                updated. This is only meaningful when performing delimited parsing.
              </para>
              <para>
                Default: ','
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.TextQualifier">
            <summary>
              Gets or sets the character that is used to enclose a string that would otherwise
              be potentially trimmed (Ex. "  this  ").
            </summary>
            <value>
              The character used to enclose a string, so that row/column delimiters are ignored
              and whitespace is preserved.
            </value>
            <remarks>
              <para>
                The Text Qualifiers must be present at the beginning and end of the column to
                have them properly removed from the ends of the string.  Furthermore, for a
                string that has been enclosed with the text qualifier, if the text qualifier is
                doubled up inside the string, the characters will be treated as an escape for
                the literal character of the text qualifier (ie. "This""Test" will translate
                with only one double quote inside the string).
              </para>
              <para>
                Setting this to <see langword="null"/> can cause a performance boost, if none of the values are
                expected to require escaping.
              </para>
              <para>
                Default: '\"'
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.EscapeCharacter">
            <summary>
              Gets or sets the character that is used to escape a character (Ex. "\"This\"").
            </summary>
            <value>The character used to escape row/column delimiters and the text qualifier.</value>
            <remarks>
              <para>
                Upon parsing the file, the escaped characters will be stripped out, leaving
                the desired character in place.  To produce the escaped character, use the
                escaped character twice (Ex. \\).  Text qualifiers are already assumed to be
                escaped if used twice.
              </para>
              <para>
                Setting this to <see langword="null"/> can cause a performance boost, if none of the values are
                expected to require escaping.
              </para>
              <para>
                Default: null
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.CommentCharacter">
            <summary>
              Gets or sets the character that is used to mark the beginning of a row that contains
              purely comments and that should not be parsed.
            </summary>
            <value>
              The character used to indicate the current row is to be ignored as a comment.
            </value>
            <remarks>
              <para>
                Default: '#'
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.Item(System.Int32)">
            <summary>
              Gets the data found in the current row of data by the column index.
            </summary>
            <value>The value of the column at the given index.</value>
            <param name="intColumnIndex">The index of the column to retreive.</param>
            <remarks>
              If the column is outside the bounds of the columns found or the column
              does not possess a name, it will return <see langword="null"/>.
            </remarks>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.Item(System.String)">
            <summary>
              Gets the data found in the current row of data by the column name.
            </summary>
            <value>The value of the column with the given column name.</value>
            <param name="strColumnName">The name of the column to retreive.</param>
            <remarks>
              If the header has yet to be parsed (or no header exists), the property will
              return <see langword="null"/>.
            </remarks>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.ColumnCount">
            <summary>
              Gets the number of columns found in the current row.
            </summary>
            <value>The number of data columns found in the current row.</value>
            <remarks>The <see cref="P:Moses.Data.Parser.GenericParser.ColumnCount"/> property is read-only.  The number of columns per row can differ, if allowed.</remarks>
        </member>
        <member name="P:Moses.Data.Parser.GenericParser.LargestColumnCount">
            <summary>
              Gets the largest column count found thusfar from parsing.
            </summary>
            <value>The largest column count found thusfar from parsing.</value>
            <remarks>The <see cref="P:Moses.Data.Parser.GenericParser.LargestColumnCount"/> property is read-only. The LargestColumnCount can increase due to rows with additional data.</remarks>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.SetDataSource(System.String)">
            <summary>
              Sets the file as the datasource.
            </summary>
            <remarks>
              If the parser is currently parsing a file, all data associated
              with the previous file is lost and the parser is reset back to
              its initial values.
            </remarks>
            <param name="strFileName">The <see cref="T:System.String"/> containing the name of the file
            to set as the data source.</param>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParser p = new GenericParser())
                  p.SetDataSource(@"C:\MyData.txt");
              </code>
            </example>
            <exception cref="T:System.ArgumentNullException">Supplying <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">Supplying a filename to a file that does not exist.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.SetDataSource(System.String,System.Text.Encoding)">
            <summary>
              Sets the file as the datasource using the provided encoding.
            </summary>
            <remarks>
              If the parser is currently parsing a file, all data associated
              with the previous file is lost and the parser is reset back to
              its initial values.
            </remarks>
            <param name="strFileName">The <see cref="T:System.String"/> containing the name of the file
            to set as the data source.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> of the file being referenced.</param>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParser p = new GenericParser())
                  p.SetDataSource(@"C:\MyData.txt", Encoding.ASCII);
              </code>
            </example>
            <exception cref="T:System.ArgumentNullException">Supplying <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">Supplying a filename to a file that does not exist.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.SetDataSource(System.IO.TextReader)">
            <summary>
              Sets the <see cref="T:System.IO.TextReader"/> as the datasource.
            </summary>
            <param name="txtReader">The <see cref="T:System.IO.TextReader"/> that contains the data to be parsed.</param>
            <remarks>
              If the parser is currently parsing a file, all data associated with the
              previous file is lost and the parser is reset back to its initial values.
            </remarks>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParser p = new GenericParser())
                  using (StreamReader srReader = new StreamReader(@"C:\MyData.txt"))
                    p.SetDataSource(srReader);
              </code>
            </example>
            <exception cref="T:System.ArgumentNullException">Supplying <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Read">
            <summary>
              <para>
                Parses the data-source till it arrives at one row of data.
              </para>
            </summary>
            <returns>
              <para>
                <see langword="true"/> - Successfully parsed a new data row.
              </para>
              <para>
                <see langword="false"/> - No new data rows were found.
              </para>
            </returns>
            <remarks>
              <para>
                If it finds a header, and its expecting a header row, it will not stop
                at the row and continue on till it has found a row of data.
              </para>
              <para>
                Internally, the header row is treated as a data row, but will not cause
                the parser to stop after finding it.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">
              Attempting to read without properly setting up the <see cref="T:Moses.Data.Parser.GenericParser"/>.
            </exception>
            <exception cref="T:Moses.Data.Parser.ParsingException">
              Thrown in the situations where the <see cref="T:Moses.Data.Parser.GenericParser"/> cannot continue
              due to a conflict between the setup and the data being parsed.
            </exception>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParser p = new GenericParser(@"C:\MyData.txt"))
                {
                  while(p.Read())
                  {
                    // Put code here to retrieve results of the read.
                  }
                }
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Load(System.Xml.XmlReader)">
            <summary>
            Loads the configuration of the <see cref="T:Moses.Data.Parser.GenericParser"/> object from an <see cref="T:System.Xml.XmlReader"/>.
            </summary>
            <param name="xrConfigXmlFile">The <see cref="T:System.Xml.XmlReader"/> containing the XmlConfig file to load configuration from.</param>
            <exception cref="T:System.ArgumentException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentException"/> could be thrown.</exception>
            <exception cref="T:System.ArgumentNullException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentNullException"/> could be thrown.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentOutOfRangeException"/> could be thrown.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
            <example>
              <code lang="C#" escaped="true">
                using (FileStream fs = new FileStream(@"C:\MyData.txt", FileMode.Open))
                  using (XmlTextReader xmlTextReader = new XmlTextReader(fs))
                    using (GenericParser p = new GenericParser())
                      p.Load(xmlTextReader);
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Load(System.IO.TextReader)">
            <summary>
            Loads the configuration of the <see cref="T:Moses.Data.Parser.GenericParser"/> object from an <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="trConfigXmlFile">The <see cref="T:System.IO.TextReader"/> containing the XmlConfig file to load configuration from.</param>
            <exception cref="T:System.ArgumentException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentException"/> could be thrown.</exception>
            <exception cref="T:System.ArgumentNullException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentNullException"/> could be thrown.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentOutOfRangeException"/> could be thrown.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
            <example>
              <code lang="C#" escaped="true">
                using (StreamReader sr = new StreamReader(@"C:\MyData.txt"))
                  using (GenericParser p = new GenericParser())
                    p.Load(sr);
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Load(System.IO.Stream)">
            <summary>
            Loads the configuration of the <see cref="T:Moses.Data.Parser.GenericParser"/> object from an <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="sConfigXmlFile">The <see cref="T:System.IO.Stream"/> containing the XmlConfig file to load configuration from.</param>
            <exception cref="T:System.ArgumentException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentException"/> could be thrown.</exception>
            <exception cref="T:System.ArgumentNullException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentNullException"/> could be thrown.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentOutOfRangeException"/> could be thrown.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
            <example>
              <code lang="C#" escaped="true">
                using (FileStream fs = new FileStream(@"C:\MyData.txt", FileMode.Open))
                  using (GenericParser p = new GenericParser())
                    p.Load(fs);
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Load(System.String)">
            <summary>
            Loads the configuration of the <see cref="T:Moses.Data.Parser.GenericParser"/> object from a file on the file system.
            </summary>
            <param name="strConfigXmlFile">The full path to the XmlConfig file on the file system.</param>
            <exception cref="T:System.ArgumentException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentException"/> could be thrown.</exception>
            <exception cref="T:System.ArgumentNullException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentNullException"/> could be thrown.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentOutOfRangeException"/> could be thrown.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParser p = new GenericParser())
                  p.Load(@"C:\MyData.txt");
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Load(System.Xml.XmlDocument)">
             <summary>
             Loads the configuration of the <see cref="T:Moses.Data.Parser.GenericParser"/> object from an <see cref="T:System.Xml.XmlDocument"/>.
             </summary>
             <param name="xmlConfig">The <see cref="T:System.Xml.XmlDocument"/> object containing the configuration information.</param>
             <exception cref="T:System.ArgumentException">In the event that the XmlConfig file contains a value that is invalid,
             an <see cref="T:System.ArgumentException"/> could be thrown.</exception>
             <exception cref="T:System.ArgumentNullException">In the event that the XmlConfig file contains a value that is invalid,
             an <see cref="T:System.ArgumentNullException"/> could be thrown.</exception>
             <exception cref="T:System.ArgumentOutOfRangeException">In the event that the XmlConfig file contains a value that is invalid,
             an <see cref="T:System.ArgumentOutOfRangeException"/> could be thrown.</exception>
             <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
             <example>
               <code lang="C#" escaped="true">
                 XmlDocument xmlConfig = new XmlDocument();
                 xmlConfig.Load(strConfigXmlFile);
            
                 using (GenericParser p = new GenericParser())
                   p.Load(xmlConfig);
               </code>
             </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Save(System.Xml.XmlWriter)">
            <summary>
              Saves the configuration to a <see cref="T:System.Xml.XmlWriter"/>.
            </summary>
            <param name="xwXmlConfig">The XmlWriter to save the the <see cref="T:System.Xml.XmlDocument"/> to.</param>
            <example>
              <code lang="C#" escaped="true">
                using (XmlTextWriter xwXmlConfig = new XmlTextWriter(@"C:\MyData.txt", Encoding.Default))
                  using (GenericParser p = new GenericParser())
                    p.Save(xwXmlConfig);
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Save(System.IO.TextWriter)">
            <summary>
              Saves the configuration to a <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="twXmlConfig">The TextWriter to save the <see cref="T:System.Xml.XmlDocument"/> to.</param>
            <example>
              <code lang="C#" escaped="true">
                using (StringWriter sw = new StringWriter())
                  using (GenericParser p = new GenericParser())
                    p.Save(sw);
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Save(System.IO.Stream)">
            <summary>
              Saves the configuration to a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="sXmlConfig">The stream to save the <see cref="T:System.Xml.XmlDocument"/> to.</param>
            <example>
              <code lang="C#" escaped="true">
                using (FileStream fs = new FileStream(@"C:\MyData.txt", FileMode.Create))
                  using (GenericParser p = new GenericParser())
                    p.Save(fs);
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Save(System.String)">
            <summary>
              Saves the configuration to the file system.
            </summary>
            <param name="strConfigXmlFile">The file name to save the <see cref="T:System.Xml.XmlDocument"/> to.</param>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParser p = new GenericParser())
                  p.Load(@"C:\MyData.txt");
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Save">
            <summary>
              Saves the configuration to an <see cref="T:System.Xml.XmlDocument"/>.
            </summary>
            <returns>The <see cref="T:System.Xml.XmlDocument"/> containing the configuration information.</returns>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParser p = new GenericParser())
                  XmlDocument xmlConfig = p.Save();
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Close">
            <summary>
              Releases the underlying resources of the <see cref="T:Moses.Data.Parser.GenericParser"/>.
            </summary>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParser p = new GenericParser())
                {
                  p.SetDataSource(@"C:\MyData.txt");
                
                  while(p.Read())
                  {
                    // Put code here to retrieve results of the read.
                  }
                }
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.GetColumnIndex(System.String)">
            <summary>
              Returns the index of the column based on its name.
            </summary>
            <remarks>
              <para>
                <see langword="null"/> column name is not a valid name for a column.
              </para>
              <para>
                If the column is not found, the column index will be -1.
              </para>
            </remarks>
            <param name="strColumnName">The name of the column to get the index for.</param>
            <returns>The index of the column with the name strColumnName. If none exists, -1 will be returned.</returns>
            <example>
              <code lang="C#" escaped="true">
                int intID, intPrice;
                bool blnGotIndices = false;
                
                using (GenericParser p = new GenericParser())
                {
                  p.SetDataSource(@"C:\MyData.txt");
                  p.FirstRowHasHeader = true;
                
                  while(p.Read())
                  {
                    if (!blnGotIndices)
                    {
                      blnGotIndices = true;
                      intID = p.GetColumnIndex("ID");
                      intPrice = p.GetColumnIndex("Price");
                    }
                  
                    // Put code here to retrieve results of the read.
                  }
                }
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.GetColumnName(System.Int32)">
            <summary>
              Returns the name of the column based on its index.
            </summary>
            <param name="intColumnIndex">The column index to return the name for.</param>
            <remarks>
              If the column is not found or the index is outside the range
              of possible columns, <see langword="null"/> will be returned.
            </remarks>
            <returns>The name of the column at the given index, if none exists <see langword="null"/> is returned.</returns>
            <example>
              <code lang="C#" escaped="true">
                string strColumn1, strColumn2;
                bool blnGotColumnNames = false;
                
                using (GenericParser p = new GenericParser())
                {
                  p.SetDataSource(@"C:\MyData.txt");
                  p.FirstRowHasHeader = true;
                
                  while(p.Read())
                  {
                    if (!blnGotColumnNames)
                    {
                      blnGotColumnNames = true;
                      strColumn1 = p.GetColumnIndex(0);
                      strColumn2 = p.GetColumnIndex(1);
                    }
                  
                    // Put code here to retrieve results of the read.
                  }
                }
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Dispose">
            <summary>
              Releases all of the underlying resources used by this instance.
            </summary>
            <remarks>
              Calls <see cref="M:Moses.Data.Parser.GenericParser.Dispose(System.Boolean)"/> with blnDisposing set to <see langword="true"/>
              to free unmanaged and managed resources.
            </remarks>
        </member>
        <member name="E:Moses.Data.Parser.GenericParser.Disposed">
            <summary>
            Occurs when this instance is diposed of.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.m_ParserState">
            <summary>
              The current <see cref="T:Moses.Data.Parser.ParserState"/> of the parser.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.m_lstData">
            <summary>
              The current values of all the parsed columns within the row.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParser.m_lstColumnNames">
            <summary>
              The current values of all the parsed column headers within the row.
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.OnDisposed">
            <summary>
            Raises the <see cref="E:Moses.Data.Parser.GenericParser.Disposed"/> Event.
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser.Dispose(System.Boolean)">
            <summary>
              Releases the all unmanaged resources used by this instance and optionally releases the managed resources.
            </summary>
            <param name="blnDisposing">
              <see langword="true"/> to release both managed and unmanaged resources; <see langword="false"/> to release only unmanaged resources.
            </param>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._InitializeParse">
            <summary>
              Initializes internal variables that are maintained for internal tracking
              of state during parsing.
            </summary>
            <exception cref="T:System.InvalidOperationException">
              In the event that the <see cref="T:Moses.Data.Parser.GenericParser"/> wasn't setup properly, this exception will be thrown.
            </exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._GetNextCharacter">
            <summary>
              Gets the next character from the input buffer (and refills it if necessary and possible).
            </summary>
            <returns>
              <para>
                <see langword="true"/> - A new character was read from the data source.
              </para>
              <para>
                <see langword="false"/> - No more characters are available in the data source.
              </para>
            </returns>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._SkipCommentRows">
            <summary>
              Reads till a non-comment row is found.
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._SkipToEndOfText">
            <summary>
              Reads till the end of the text is found.
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._CleanUpParser(System.Boolean)">
            <summary>
              Removes all references to internally allocated resources.  Depending on
              <paramref name="blnCompletely"/>, it will free up all of the internal resources
              to prepare the instance for disposing.
            </summary>
            <param name="blnCompletely">
              <para>
                <see langword="true"/> - Clean-up the entire parser (used for disposing the instance).
              </para>
              <para>
                <see langword="false"/> - Clean-up the parser to all it to be reused later.
              </para>
            </param>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._ParseRowType">
            <summary>
              Examines the beginning of the row and the current state information
              to determine how the parser will interpret the next line and updates
              the internal RowType accordingly.
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._SetColumnNames">
            <summary>
              Takes the data parsed from the row and places it into the ColumnNames collection.
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._HandleEndOfRow(System.Int32)">
            <summary>
              Handles the logic necessary for updating state due to a row ending.
            </summary>
            <param name="intEndOfDataIndex">The index of the last character in the column.</param>
            <exception cref="T:Moses.Data.Parser.ParsingException">
              If parsing a fixed width format and the number of columns found differs
              what was expected, this exception will be thrown.
            </exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._ExtractColumn(System.Int32)">
            <summary>
              Takes a range within the character buffer and extracts the desired
              string from within it and places it into the DataArray.  If an escape
              character has been set, the escape characters are stripped out and the
              unescaped string is returned.
            </summary>
            <param name="intEndOfDataIndex">The index of the last character in the column.</param>
            <exception cref="T:Moses.Data.Parser.ParsingException">
              In the event that the <see cref="P:Moses.Data.Parser.GenericParser.ExpectedColumnCount"/> is set to a value of greater
              than zero (which is by default for a fixed width format) and the number of columns
              found differs from what's expected, this exception will be thrown.
            </exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._CopyRemainingDataToFront(System.Int32)">
            <summary>
              When the buffer has reached the end of its parsing and there are no more
              complete columns to be parsed, the remaining data must be moved up to the
              front of the buffer so that the next batch of data can be appended to
              the end.
            </summary>
            <param name="intStartIndex">The index that starts the beginning of the data to be moved.</param>
            <exception cref="T:Moses.Data.Parser.ParsingException">In the event that the entire buffer is full and a single
            column cannot be parsed from it, parsing can no longer continue.</exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._GetColumnName(System.Int32)">
            <summary>
              Returns the name of the Column based on its ColumnIndex.
            </summary>
            <param name="intColumnIndex">The column index to return the name for.</param>
            <remarks>
              If the column is not found or the index is outside the range
              of possible columns, <see langword="null"/> will be returned.
            </remarks>
            <returns>The name of the column at the given ColumnIndex, if
            none exists <see langword="null"/> is returned.</returns>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._GetColumnIndex(System.String)">
            <summary>
              Returns the index of the Column based on its Name.
            </summary>
            <remarks>
              <para>
                <see langword="null"/> column name is not a valid name for a column.
              </para>
              <para>
                If the column is not found, the column index will be -1.
              </para>  
            </remarks>
            <param name="strColumnName">The name of the column to find the index for.</param>
            <returns>The index of the column with the name strColumnName.
            If none exists, -1 will be returned.</returns>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._CreateParsingException(System.String)">
            <summary>
              Creates a detailed message for a parsing exception and then throws it.
            </summary>
            <param name="strMessage">The exception specific information to go into the <see cref="T:Moses.Data.Parser.ParsingException"/>.</param>
            <returns>The <see cref="T:Moses.Data.Parser.ParsingException"/> with the provided message.</returns>
        </member>
        <member name="M:Moses.Data.Parser.GenericParser._InitializeConfigurationVariables">
            <summary>
              Initializes the parsing variables for the GenericParser.
            </summary>
        </member>
        <member name="T:Moses.Data.Parser.GenericParserAdapter">
            <summary>
              The <see cref="T:Moses.Data.Parser.GenericParserAdapter"/> is used to modify the <see cref="T:Moses.Data.Parser.GenericParser"/>
              to allow it parse a file and place them into various formats.
            </summary>
            <threadsafety static="false" instance="false"/>
        </member>
        <member name="F:Moses.Data.Parser.GenericParserAdapter.DefaultIncludeFileLineNumber">
            <summary>
              Defines the default value for including the file line number (false).
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.GenericParserAdapter.DefaultSkipEndingDataRows">
            <summary>
              Defines the number of skip ending data rows (0).
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.GenericParserAdapter.AddColumnToTable(System.Data.DataTable,System.String)">
            <summary>
              Adds a column name to the given <see cref="T:System.Data.DataTable"/>, such that
              it ensures a unique column name.
            </summary>
            <param name="dtData">The <see cref="T:System.Data.DataTable"/> to add the column to.</param>
            <param name="strColumnName">The desired column name to add.</param>
        </member>
        <member name="M:Moses.Data.Parser.GenericParserAdapter.#ctor">
            <summary>
              Constructs an instance of a <see cref="T:Moses.Data.Parser.GenericParserAdapter"/>
              with the default settings.
            </summary>
            <remarks>
              When using this constructor, the datasource must be set prior to using the parser
              (using <see cref="M:Moses.Data.Parser.GenericParser.SetDataSource(System.String)"/>), otherwise an exception will be thrown.
            </remarks>
        </member>
        <member name="M:Moses.Data.Parser.GenericParserAdapter.#ctor(System.String)">
            <summary>
              Constructs an instance of a <see cref="T:Moses.Data.Parser.GenericParserAdapter"/> and sets
              the initial datasource as the file referenced by the string passed in.
            </summary>
            <param name="strFileName">The file name to set as the initial datasource.</param>
        </member>
        <member name="M:Moses.Data.Parser.GenericParserAdapter.#ctor(System.String,System.Text.Encoding)">
            <summary>
              Constructs an instance of a <see cref="T:Moses.Data.Parser.GenericParserAdapter"/> and sets
              the initial datasource as the file referenced by the string passed in with
              the provided encoding.
            </summary>
            <param name="strFileName">The file name to set as the initial datasource.</param>
            <param name="encoding">The <see cref="T:System.Text.Encoding"/> of the file being referenced.</param>
        </member>
        <member name="M:Moses.Data.Parser.GenericParserAdapter.#ctor(System.IO.TextReader)">
            <summary>
              Constructs an instance of a <see cref="T:Moses.Data.Parser.GenericParserAdapter"/> and sets
              the initial datasource as the <see cref="T:System.IO.TextReader"/> passed in.
            </summary>
            <param name="txtReader">
              The <see cref="T:System.IO.TextReader"/> containing the data to be parsed.
            </param>
        </member>
        <member name="P:Moses.Data.Parser.GenericParserAdapter.IncludeFileLineNumber">
            <summary>
              Gets or sets whether or not the <see cref="P:Moses.Data.Parser.GenericParser.FileRowNumber"/> from where
              the data was retrieved should be included as part of the result set.
            </summary>
            <remarks>
              <para>
                Default: <see langword="false"/> 
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="P:Moses.Data.Parser.GenericParserAdapter.SkipEndingDataRows">
            <summary>
              Gets or sets the number of rows of data to ignore at the end of the file.
            </summary>
            <value>The number of data rows to skip at the end of the datasource</value>
            <remarks>
              <para>
                A value of zero will ensure no rows are ignored.
              </para>
              <para>
                Default: 0 
              </para>
              <para>
                If parsing has started, this value cannot be updated.
              </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParserAdapter.GetXml">
            <summary>
              Generates an <see cref="T:System.Xml.XmlDocument"/> based on the data stored within
              the entire data source after it was parsed.
            </summary>
            <returns>
              The <see cref="T:System.Xml.XmlDocument"/> containing all of the data in the data
              source.
            </returns>
            <exception cref="T:System.InvalidOperationException">
              Attempting to read without properly setting up the <see cref="T:Moses.Data.Parser.GenericParserAdapter"/>.
            </exception>
            <exception cref="T:Moses.Data.Parser.ParsingException">
              Thrown in the situations where the <see cref="T:Moses.Data.Parser.GenericParserAdapter"/> cannot continue
              due to a conflict between the setup and the data being parsed.
            </exception>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParserAdapter p = new GenericParserAdapter(@"C:\MyData.txt"))
                  XmlDocument xmlDoc = p.GetXml();
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParserAdapter.GetDataSet">
            <summary>
              Generates a <see cref="T:System.Data.DataSet"/> based on the data stored within
              the entire data source after it was parsed.
            </summary>
            <returns>
              The <see cref="T:System.Data.DataSet"/> containing all of the data in the
              data source.
            </returns>
            <exception cref="T:System.InvalidOperationException">
              Attempting to read without properly setting up the <see cref="T:Moses.Data.Parser.GenericParserAdapter"/>.
            </exception>
            <exception cref="T:Moses.Data.Parser.ParsingException">
              Thrown in the situations where the <see cref="T:Moses.Data.Parser.GenericParserAdapter"/> cannot continue
              due to a conflict between the setup and the data being parsed.
            </exception>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParserAdapter p = new GenericParserAdapter(@"C:\MyData.txt"))
                  DataSet dsResults = p.GetDataSet();
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParserAdapter.GetDataTable">
            <summary>
              Generates a <see cref="T:System.Data.DataTable"/> based on the data stored within
              the entire data source after it was parsed.
            </summary>
            <returns>
              The <see cref="T:System.Data.DataTable"/> containing all of the data in the data
              source.
            </returns>
            <exception cref="T:System.InvalidOperationException">
              Attempting to read without properly setting up the <see cref="T:Moses.Data.Parser.GenericParserAdapter"/>.
            </exception>
            <exception cref="T:Moses.Data.Parser.ParsingException">
              Thrown in the situations where the <see cref="T:Moses.Data.Parser.GenericParserAdapter"/> cannot continue
              due to a conflict between the setup and the data being parsed.
            </exception>
            <example>
              <code lang="C#" escaped="true">
                using (GenericParserAdapter p = new GenericParserAdapter(@"C:\MyData.txt"))
                  DataTable dtResults = p.GetDataTable();
              </code>
            </example>
        </member>
        <member name="M:Moses.Data.Parser.GenericParserAdapter.Load(System.Xml.XmlDocument)">
            <summary>
              Loads the base <see cref="T:Moses.Data.Parser.GenericParser"/> class from the
              <see cref="T:System.Xml.XmlDocument"/> and then retrieves additional information
               from the Xml that is specific to the <see cref="T:Moses.Data.Parser.GenericParserAdapter"/>.
            </summary>
            <param name="xmlConfig">
              The <see cref="T:System.Xml.XmlDocument"/> containing the configuration information.
            </param>
            <exception cref="T:System.ArgumentException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentException"/> could be thrown.</exception>
            <exception cref="T:System.ArgumentNullException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentNullException"/> could be thrown.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">In the event that the XmlConfig file contains a value that is invalid,
            an <see cref="T:System.ArgumentOutOfRangeException"/> could be thrown.</exception>
            <exception cref="T:System.InvalidOperationException">Attempting to modify the configuration, while parsing.</exception>
        </member>
        <member name="M:Moses.Data.Parser.GenericParserAdapter.Save">
            <summary>
              Saves the configuration of the <see cref="T:Moses.Data.Parser.GenericParserAdapter"/>
              to an <see cref="T:System.Xml.XmlDocument"/>.
            </summary>
            <returns>
              The <see cref="T:System.Xml.XmlDocument"/> that will store the configuration
              information of the current setup of the <see cref="T:Moses.Data.Parser.GenericParserAdapter"/>.
            </returns>
        </member>
        <member name="T:Moses.Data.Parser.ParserState">
            <summary>
            The current internal state of the parser.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.ParserState.NoDataSource">
            <summary>
              Indicates that the parser has no datasource and is not properly setup.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.ParserState.Ready">
            <summary>
              Indicates that the parser is ready to begin parsing.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.ParserState.Parsing">
            <summary>
              Indicates that the parser is currently parsing the datasource.
            </summary>
        </member>
        <member name="F:Moses.Data.Parser.ParserState.Finished">
            <summary>
              Indicates that the parser has finished parsing the datasource.
            </summary>
        </member>
        <member name="T:Moses.Data.Parser.ParsingException">
            <summary>
              <see cref="T:Moses.Data.Parser.ParsingException"/> is an exception class meant for states where
              the parser can no longer continue parsing due to the data found in the
              data-source.
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.ParsingException.#ctor">
            <summary>
              Creates a new <see cref="T:Moses.Data.Parser.ParsingException"/> with default values.
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.ParsingException.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
              Creates a new <see cref="T:Moses.Data.Parser.ParsingException"/> containing a message and the
              file line number that the error occured.
            </summary>
            <param name="strMessage">
              The message indicating the root cause of the error.
            </param>
            <param name="intFileRowNumber">The file line number the error occured on.</param>
            <param name="intColumnNumber">The column number the error occured on.</param>
        </member>
        <member name="M:Moses.Data.Parser.ParsingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Creates a new <see cref="T:Moses.Data.Parser.ParsingException"/> with seralized data.
            </summary>
            <param name="sInfo">
              The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that contains information
              about the exception.
            </param>
            <param name="sContext">
              The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains information
              about the source/destination of the exception.
            </param>
        </member>
        <member name="P:Moses.Data.Parser.ParsingException.FileRowNumber">
            <summary>
              The line number in the file that the exception was thrown at.
            </summary>
        </member>
        <member name="P:Moses.Data.Parser.ParsingException.ColumnNumber">
            <summary>
              The column number in the file that the exception was thrown at.
            </summary>
        </member>
        <member name="M:Moses.Data.Parser.ParsingException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> 
              with information about the exception.
            </summary>
            <param name="info">
              The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data
              about the exception being thrown.
            </param>
            <param name="context">
              The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source
              or destination.
            </param>
        </member>
        <member name="T:Moses.IComposedItemContainer`1">
            <summary>
            A classe que deve implementar IComposedItemContainer para 
            </summary>
            <typeparam name="K"></typeparam>
        </member>
        <member name="P:Moses.IComposedItemContainer`1.DataItem">
            <summary>
            Entity que está contida na classe que implementa IComposedItemConainer
            </summary>
        </member>
        <member name="T:Moses.IPropertyValueHolder">
            <summary>
            A classe que implementa IProperyValueHolder deve se responsabilizar em serializar propriedades
            para entidades com um campo string representando várias proriedades (formato JSon).
            
            </summary>
            <remarks>
            Geralmente a entidade que implementa IPropertyValueHolder possui um campo chamado PropertyValues
            que guarda uma coletânea de campos "customizáveis" de forma serializada
            </remarks>
        </member>
        <member name="T:Moses.SettingsAccessor">
            <summary>
            Classe utilizada para acessar o qualquer item com ProfileId que guarda uma chave de padrão string
            </summary>
        </member>
        <member name="M:Moses.Extensions.FormatHelper.SafeStringFormat(System.String,Moses.Extensions.TypeString,System.Predicate{System.String})">
            <summary>
            Método padrão genérico para formatação de entradas de dados.
            </summary>
            <param name="input"></param>
            <param name="formatString"></param>
            <returns></returns>
        </member>
        <member name="M:Moses.Extensions.FormatHelper.SpellCurrencyOut(System.Decimal)">
            <summary>
            Escreve o valor por extenso
            </summary>
            <param name="currency"></param>
            <returns></returns>
        </member>
        <member name="T:Moses.Extensions.OfxHelper">
            <summary>
            
            </summary>
            <author>
            Rodrigo Diniz / Joe Mcbride
            </author>
        </member>
        <member name="M:Moses.Extensions.OfxHelper.OfxParseToXElement(System.String)">
            <summary>
            Parses the ofx file data and turns it into valid xml.
            </summary>
            <param name="ofxData">The ofx data.</param>
            <returns>An xml representation of the ofx data.</returns>
        </member>
        <member name="M:Moses.Extensions.OfxHelper.GetTagName(System.String)">
            <summary>
            Get the Tag name to create an Xelement
            </summary>
            <param name="line">One line from the file</param>
            <returns></returns>
        </member>
        <member name="M:Moses.Extensions.OfxHelper.GetTagValue(System.String)">
            <summary>
            Get the value of the tag to put on the Xelement
            </summary>
            <param name="line">The line</param>
            <returns></returns>
        </member>
        <member name="T:Moses.Extensions.OfxAccountDTO">
            <summary>
            After the ImportOfx class parses the data we’re now ready to convert it to simple DTOs.  Here are the DTOs I have created and the transform I used.  Notice that some of the tags are allowed to be null.
            </summary>
        </member>
        <member name="T:Moses.Extensions.CryptProvider">
            <summary>
            Enumerator com os tipos de classes para criptografia.
            </summary>
        </member>
        <member name="F:Moses.Extensions.CryptProvider.Rijndael">
            <summary>
            Representa a classe base para implementações criptografia dos algoritmos simétricos Rijndael.
            </summary>
        </member>
        <member name="F:Moses.Extensions.CryptProvider.RC2">
            <summary>
            Representa a classe base para implementações do algoritmo RC2.
            </summary>
        </member>
        <member name="F:Moses.Extensions.CryptProvider.DES">
            <summary>
            Representa a classe base para criptografia de dados padrões (DES - Data Encryption Standard).
            </summary>
        </member>
        <member name="F:Moses.Extensions.CryptProvider.TripleDES">
            <summary>
            Representa a classe base (TripleDES - Triple Data Encryption Standard).
            </summary>
        </member>
        <member name="T:Moses.Extensions.SecurityHelper.Crypt">
            <summary>
            Classe auxiliar com métodos para criptografia de dados.
            </summary>
        </member>
        <member name="P:Moses.Extensions.SecurityHelper.Crypt.Key">
            <summary>
            Chave secreta para o algoritmo simétrico de criptografia.
            </summary>
        </member>
        <member name="M:Moses.Extensions.SecurityHelper.Crypt.#ctor">
            <summary>
            Contrutor padrão da classe, é setado um tipo de criptografia padrão.
            </summary>
        </member>
        <member name="M:Moses.Extensions.SecurityHelper.Crypt.#ctor(Moses.Extensions.CryptProvider)">
            <summary>
            Construtor com o tipo de criptografia a ser usada.
            </summary>
            <param name="cryptProvider">Tipo de criptografia.</param>
        </member>
        <member name="M:Moses.Extensions.SecurityHelper.Crypt.GetKey">
            <summary>
            Gera a chave de criptografia válida dentro do array.
            </summary>
            <returns>Chave com array de bytes.</returns>
        </member>
        <member name="M:Moses.Extensions.SecurityHelper.Crypt.Encrypt(System.String)">
            <summary>
            Encripta o dado solicitado.
            </summary>
            <param name="plainText">Texto a ser criptografado.</param>
            <returns>Texto criptografado.</returns>
        </member>
        <member name="M:Moses.Extensions.SecurityHelper.Crypt.Decrypt(System.String)">
            <summary>
            Desencripta o dado solicitado.
            </summary>
            <param name="cryptoText">Texto a ser descriptografado.</param>
            <returns>Texto descriptografado.</returns>
        </member>
        <member name="M:Moses.Extensions.ParseHelper.ParseCPF(System.String)">
            <summary>
            Prepara a sequência de entrada para ser armazenada no datasource.
            </summary>
            <remarks>Assume-se que a sequência de entrada é valida</remarks>
            <param name="s"></param>
        </member>
        <member name="M:Moses.Extensions.ParseHelper.ParseCPF(System.Object)">
            <summary>
            Prepara a sequência de entrada para ser armazenada no datasource.
            </summary>
            <remarks>Assume-se que a sequência de entrada é valida</remarks>
            <param name="s"></param>
        </member>
        <member name="M:Moses.Extensions.ParseHelper.ParseSearch(System.String)">
            <summary>
            Prepara uma string para ser utilizada em uma busca
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Moses.Extensions.ParseHelper.ToHexString(System.Byte[])">
            <summary>
            Converte uma array de bytes para uma string em hexadecimal
            </summary>
            <param name="bytes"></param>
            <returns></returns>
            <author>http://www.nathanm.com/csharp-convert-hex-string-tofrom-byte-array-fast/</author>
        </member>
        <member name="M:Moses.Extensions.ParseHelper.HexStringToByteArray(System.String)">
            <summary>
            Converte uma string em hexadecimal em uma array em bytes
            </summary>
            <param name="hex"></param>
            <returns></returns>
            <author>http://www.nathanm.com/csharp-convert-hex-string-tofrom-byte-array-fast/</author>
        </member>
        <member name="M:Moses.Extensions.ParseHelper.RemoveAccents(System.String)">
            <summary>
            Remove a acentuação de uma String
            </summary>
            <param name="text"></param>
            <returns>String</returns>
        </member>
        <member name="M:Moses.Extensions.ParseHelper.CompareInsensitive(System.Object,System.String,System.Boolean)">
            <summary>
            Verifica se um objeto do banco é igual ao objeto informado pelo usuário.Ignorando acentuação letras maiúsculas ou minúsculas
            </summary>
            <param name="objeto">Objeto do banco</param>
            <param name="strComparar">Valor informado pelo usuário</param>
            <param name="removerAcentos">Valor que define se serão removidas as acentuações</param>
            <returns>Booleano</returns>
        </member>
        <member name="T:Moses.Extensions.Validators">
            <summary>
            Classe criada para realizar validação de dados convencionados pela Exodus
            </summary>
            
        </member>
        <member name="M:Moses.Extensions.Validators.IsValidCpfCnpj(System.String)">
            <summary>
            Diz se a seqûencia é um CNPJ ou CPF válido
            </summary>
            <param name="cpfCnpj"></param>
            <returns></returns>
        </member>
        <member name="M:Moses.Extensions.Validators.IsValidCpf(System.String)">
            <summary>
            Diz se a sequência em questão é um CPF válido
            </summary>
            <param name="cpf"></param>
            <returns>Retorna verdadeiro se o CPF for válido ou a string for nula ou vazia</returns>
        </member>
        <member name="M:Moses.Extensions.Validators.IsValidCpf(System.Decimal)">
            <summary>
            Diz se a sequência em questão é um CPF válido
            </summary>
            <author>Olavo Rocha Neto</author>
            <param name="cpf"></param>
            <returns></returns>
        </member>
        <member name="M:Moses.Extensions.Validators.IsValidEmailAddress(System.String)">
            <summary>
            Determina se uma sequência representa um e-mail válido. 
            </summary>
            <remarks>Strings vazias ou nulas são declaradas válidas</remarks>
            <author>Olavo Neto</author>
            <param name="sEmail">sequência de entrada</param>
            <returns></returns>
        </member>
        <member name="M:Moses.Extensions.Validators.ValidateRequired(System.String,System.String)">
            <summary>
            Valida se a string é não-nula ou vazia
            </summary>
            <param name="value">Valor do Parâmetro</param>
            <param name="parameterName">Nome do parâmetro a ser validado</param>
            <exception cref="T:System.ArgumentException" ></exception>
        </member>
        <member name="M:Moses.Extensions.Validators.EqualsIgnoreCase(System.String,System.String)">
            <summary>
            Compara duas strings ignorando se as duas são case sensitive
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Moses.Import.CieloDocumentParser.ImportTransations(Moses.Import.CieloDocument,System.Data.DataTable)">
            <summary>
            Importa as transações de um relatório da cielo
            </summary>
            <param name="csv">conteudo csv do relatorio</param>
            <returns>List of transactions found in OFX document</returns>
        </member>
        <member name="M:Moses.Import.CieloDocumentParser.ParseHeader(System.Data.DataTable)">
            <summary>
            Verifica se o arquivo é o relatório da cielo. Remove o cabeçalho.
            </summary>
            <param name="csv">arquivo da cielo em datatable</param>
            <returns>tabela sem o cabecalho</returns>
        </member>
        <member name="M:Moses.Ofx.Account.InitializeBank(System.Xml.XmlNode)">
            <summary>
            Initializes information specific to bank
            </summary>
        </member>
        <member name="T:Moses.Ofx.Ofx">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Moses.Ofx.Ofx.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Moses.Ofx.Ofx.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Moses.Ofx.Ofx.BankAccount">
            <summary>
              Looks up a localized string similar to OFX/BANKMSGSRSV1/STMTTRNRS/STMTRS[1].
            </summary>
        </member>
        <member name="P:Moses.Ofx.Ofx.CCAccount">
            <summary>
              Looks up a localized string similar to OFX/CREDITCARDMSGSRSV1/CCSTMTTRNRS/CCSTMTRS.
            </summary>
        </member>
        <member name="P:Moses.Ofx.Ofx.InsufficentFunds">
            <summary>
              Looks up a localized string similar to There are insufficent funds to pay your {item}. We have allocated what you have evenly between the {item} but there is no room in the budget for anything else, sorry....
            </summary>
        </member>
        <member name="P:Moses.Ofx.Ofx.NoFunds">
            <summary>
              Looks up a localized string similar to There are no funds for your {item} sorry....
            </summary>
        </member>
        <member name="P:Moses.Ofx.Ofx.NoMoney">
            <summary>
              Looks up a localized string similar to You are spending beyond your means so we have had to use your savings to create this budget. Perhaps you need to review your spending....
            </summary>
        </member>
        <member name="P:Moses.Ofx.Ofx.SignOn">
            <summary>
              Looks up a localized string similar to OFX/SIGNONMSGSRSV1/SONRS.
            </summary>
        </member>
        <member name="M:Moses.Ofx.OFXDocumentParser.GetXPath(Moses.Ofx.AccountType,Moses.Ofx.OFXDocumentParser.OFXSection)">
            <summary>
            Returns the correct xpath to specified section for given account type
            </summary>
            <param name="type">Account type</param>
            <param name="section">Section of OFX document, e.g. Transaction Section</param>
            <exception cref="T:Moses.Ofx.OFXException">Thrown in account type not supported</exception>
        </member>
        <member name="M:Moses.Ofx.OFXDocumentParser.ImportTransations(Moses.Ofx.OFXDocument,System.Xml.XmlDocument)">
            <summary>
            Returns list of all transactions in OFX document
            </summary>
            <param name="doc">OFX document</param>
            <returns>List of transactions found in OFX document</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Moses.Ofx.OFXDocumentParser.GetAccountType(System.String)" -->
        <member name="M:Moses.Ofx.OFXDocumentParser.IsXmlVersion(System.String)">
            <summary>
            Check if OFX file is in SGML or XML format
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Moses.Ofx.OFXDocumentParser.SGMLToXML(System.String)">
            <summary>
            Converts SGML to XML
            </summary>
            <param name="file">OFX File (SGML Format)</param>
            <returns>OFX File in XML format</returns>
        </member>
        <member name="M:Moses.Ofx.OFXDocumentParser.ParseHeader(System.String)">
            <summary>
            Checks that the file is supported by checking the header. Removes the header.
            </summary>
            <param name="file">OFX file</param>
            <returns>File, without the header</returns>
        </member>
        <member name="M:Moses.Ofx.OFXDocumentParser.CheckHeader(System.String[])">
            <summary>
            Checks that all the elements in the header are supported
            </summary>
            <param name="header">Header of OFX file in array</param>
        </member>
        <member name="T:Moses.Ofx.OFXDocumentParser.OFXSection">
            <summary>
            Section of OFX Document
            </summary>
        </member>
        <member name="M:Moses.Ofx.OFXHelperMethods.GetBankAccountType(System.String)">
            <summary>
            Converts string representation of AccountInfo to enum AccountInfo
            </summary>
            <param name="bankAccountType">representation of AccountInfo</param>
            <returns>AccountInfo</returns>
        </member>
        <member name="M:Moses.Ofx.OFXHelperMethods.ToDate(System.String)">
            <summary>
            Flips date from YYYYMMDD to DDMMYYYY         
            </summary>
            <param name="date">Date in YYYYMMDD format</param>
            <returns>Date in format DDMMYYYY[GMT:-3]</returns>
        </member>
        <member name="M:Moses.Ofx.OFXHelperMethods.GetValue(System.Xml.XmlNode,System.String)">
            <summary>
            Returns value of specified node
            </summary>
            <param name="node">Node to look for specified node</param>
            <param name="xpath">XPath for node you want</param>
            <returns></returns>
        </member>
        <member name="M:Moses.Ofx.Transaction.GetTransactionType(System.String)">
            <summary>
            Returns TransactionType from string version
            </summary>
            <param name="transactionType">string version of transaction type</param>
            <returns>Enum version of given transaction type string</returns>
        </member>
        <member name="M:Moses.Ofx.Transaction.GetTransactionCorrectionType(System.String)">
            <summary>
            Returns TransactionCorrectionType from string version
            </summary>
            <param name="transactionCorrectionType">string version of Transaction Correction Type</param>
            <returns>Enum version of given TransactionCorrectionType string</returns>
        </member>
        <member name="M:Moses.Ofx.Transaction.NodeExists(System.Xml.XmlNode,System.String)">
            <summary>
            Checks if a node exists
            </summary>
            <param name="node">Node to search in</param>
            <param name="xpath">XPath to node you want to see if exists</param>
            <returns></returns>
        </member>
        <member name="T:Moses.Reflection.IPropertyAccessor">
            <summary>
            The IPropertyAccessor interface defines a property
            accessor.
            </summary>
        </member>
        <member name="M:Moses.Reflection.IPropertyAccessor.Get(System.Object)">
            <summary>
            Gets the value stored in the property for
            the specified target.
            </summary>
            <param name="target">Object to retrieve
            the property from.</param>
            <returns>Property value.</returns>
        </member>
        <member name="M:Moses.Reflection.IPropertyAccessor.Set(System.Object,System.Object)">
            <summary>
            Sets the value for the property of
            the specified target.
            </summary>
            <param name="target">Object to set the
            property on.</param>
            <param name="value">Property value.</param>
        </member>
        <member name="T:Moses.Reflection.PropertyAccessor">
            <summary>
            The PropertyAccessor class provides fast dynamic access
            to a property of a specified target class.
            </summary>
        </member>
        <member name="M:Moses.Reflection.PropertyAccessor.#ctor(System.Type,System.String)">
            <summary>
            Creates a new property accessor.
            </summary>
            <param name="targetType">Target object type.</param>
            <param name="property">Property name.</param>
        </member>
        <member name="M:Moses.Reflection.PropertyAccessor.Get(System.Object)">
            <summary>
            Gets the property value from the specified target.
            </summary>
            <param name="target">Target object.</param>
            <returns>Property value.</returns>
        </member>
        <member name="M:Moses.Reflection.PropertyAccessor.Get``1(System.Object)">
            <summary>
            Gets the property value from the specified target.
            </summary>
            <param name="target">Target object.</param>
            <returns>Property value.</returns>
        </member>
        <member name="M:Moses.Reflection.PropertyAccessor.Set(System.Object,System.Object)">
            <summary>
            Sets the property for the specified target.
            </summary>
            <param name="target">Target object.</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="P:Moses.Reflection.PropertyAccessor.CanRead">
            <summary>
            Whether or not the Property supports read access.
            </summary>
        </member>
        <member name="P:Moses.Reflection.PropertyAccessor.CanWrite">
            <summary>
            Whether or not the Property supports write access.
            </summary>
        </member>
        <member name="P:Moses.Reflection.PropertyAccessor.TargetType">
            <summary>
            The Type of object this property accessor was
            created for.
            </summary>
        </member>
        <member name="P:Moses.Reflection.PropertyAccessor.PropertyType">
            <summary>
            The Type of the Property being accessed.
            </summary>
        </member>
        <member name="M:Moses.Reflection.PropertyAccessor.Init">
            <summary>
            This method generates creates a new assembly containing
            the Type that will provide dynamic access.
            </summary>
        </member>
        <member name="M:Moses.Reflection.PropertyAccessor.InitTypes">
            <summary>
            Thanks to Ben Ratzlaff for this snippet of code
            http://www.codeproject.com/cs/miscctrl/CustomPropGrid.asp
            
            "Initialize a private hashtable with type-opCode pairs 
            so i dont have to write a long if/else statement when outputting msil"
            </summary>
        </member>
        <member name="M:Moses.Reflection.PropertyAccessor.EmitAssembly">
            <summary>
            Create an assembly that will provide the get and set methods.
            </summary>
        </member>
        <member name="M:Moses.RandomUtils.RandomString(System.Nullable{System.Int32},System.Nullable{System.Boolean})">
            <summary>
            
            </summary>
            <param name="size"></param>
            <param name="lowerCase">Se for null, são ambos</param>
            <returns></returns>
        </member>
        <member name="T:Moses.Test.TestHelper">
            <summary>
            Helper de Métodos de Testes
            </summary>
            <seealso cref="!:http://manfred-ramoser.blogspot.com/"/>
        </member>
        <member name="M:Moses.Test.TestHelper.CompareObjectAttributes(System.Object,System.Object)">
            <summary>
            Compara as pripriedades dos objetos
            </summary>
            <param name="firstObject"></param>
            <param name="secondObject"></param>
            <returns></returns>
        </member>
        <member name="T:Moses.Utils">
            <summary>
            Summary description for ClsUtilidades.
            </summary>
        </member>
        <member name="M:Moses.Utils.EmitMessage(Moses.MessageTypeOptions,System.String,System.String)">
            <summary>
            Método de Menssagens
            </summary>
            <param name="TipoMenssagem">Enumerador do tipo de menssagens podem ser: MsgCPF, MsgCNPJ, MsgExcluir, MsgGravacao, MsgNovo, MsgInformacao, MsgConfirmacao </param>
            <param name="message">String da menssagem quem deverá aparecer no box</param>
            <param name="caption">String do título da menssagem</param>
            <returns>retorna um valor boleano</returns>
        </member>
        <member name="M:Moses.Utils.IsNumber(System.String)">
            <summary>
            Determina se a sequência é um número inteiro
            </summary>
            <param name="InNumber"></param>
            <returns></returns>
        </member>
        <member name="M:Moses.Utils.IsDecimal(System.String)">
            <summary>
            Determina se a sequência é um número
            </summary>
            <param name="InNumber"></param>
            <returns></returns>
        </member>
        <member name="M:Moses.Utils.GetNumbers(System.String)">
            <summary>
            Pega apenas os algarismos dentro de uma sequência string
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
